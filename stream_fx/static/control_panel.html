<!DOCTYPE html>
<html>
<head>
    <title>StreamFX Control</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 20px; background-color: #f0f2f5; color: #1c1e21; }
        .main-container { max-width: 800px; margin: 0 auto; }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;}
        .header h1 { margin: 0; color: #1877f2; }
        .header-controls button { margin-left: 10px; }
        .columns { display: flex; gap: 20px; }
        .column { flex: 1; background-color: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: opacity 0.3s; }
        .column.disabled { opacity: 0.5; pointer-events: none; background-color: #f0f2f5; }
        h2 { font-size: 1.2em; color: #606770; border-bottom: 1px solid #ddd; padding-bottom: 10px; margin-top: 0; }
        h3 { font-size: 1em; color: #606770; margin-top: 20px; margin-bottom: 10px; }
        .filter-list { min-height: 200px; list-style-type: none; padding: 0; }
        .filter-item { background-color: #e4e6eb; color: #050505; padding: 10px; margin-bottom: 8px; border-radius: 6px; user-select: none; }
        .filter-item.individually-disabled { opacity: 0.6; }
        .filter-item-header { display: flex; justify-content: space-between; align-items: center; }
        .active-item { cursor: grab; }
        .active-item:active { cursor: grabbing; }
        .filter-item-controls { display: flex; align-items: center; gap: 8px; }
        .remove-btn { cursor: pointer; color: #606770; font-weight: bold; padding: 0 5px; }
        .add-btn { background-color: #ccd0d5; border-radius: 4px; padding: 2px 6px; font-size: 0.9em; border: none; cursor: pointer; }
        .dragging { opacity: 0.5; }
        .small-btn { font-size: 0.8em; padding: 6px 10px; cursor: pointer; background-color: #ddd; border: none; border-radius: 4px; }
        .param-controls { margin-top: 10px; padding-top: 10px; border-top: 1px solid #ccc; font-size: 0.9em; }
        details > summary { font-weight: bold; cursor: pointer; }
        details { margin-top: 8px; }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="header">
            <h1>StreamFX Control</h1>
            <div class="header-controls">
                <button id="clear-stack-btn" class="small-btn">Clear All</button>
                <button id="toggle-all-btn" class="small-btn">Disable All</button>
            </div>
        </div>
        <div class="columns" id="columns-container">
            <div class="column" id="available-column">
                <h2>Available Filters</h2>
                <div id="available-filters-container"></div>
            </div>
            <div class="column" id="active-column">
                <h2>Active Filter Stack</h2>
                <ul id="active-filters" class="filter-list"></ul>
            </div>
        </div>
    </div>
    <script>
        const availableContainer = document.getElementById('available-filters-container');
        const activeList = document.getElementById('active-filters');
        const clearStackBtn = document.getElementById('clear-stack-btn');
        const toggleAllBtn = document.getElementById('toggle-all-btn');
        const activeColumn = document.getElementById('active-column');
        
        let availableFiltersByCategory = {};
        let allFiltersFlat = [];
        let activeEffects = [];
        let effectsEnabled = true;
        let parameterValues = {};
        let disabledFilters = new Set();
        let draggedItem = null;

        async function sendStackUpdate() {
            const newStack = Array.from(activeList.children).map(item => item.dataset.identifier);
            try {
                const response = await fetch('/control/set_stack', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ effects: newStack })
                });
                const data = await response.json();
                activeEffects = data.active_effects;
                renderLists();
            } catch (error) {
                console.error('Failed to update stack:', error);
            }
        }

        async function sendParameterUpdate(filterId, paramId, value) {
            try {
                if (!parameterValues[filterId]) parameterValues[filterId] = {};
                parameterValues[filterId][paramId] = value;

                await fetch('/control/update_parameter', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filter_id: filterId, params: { [paramId]: value } })
                });
            } catch (error) {
                console.error(`Failed to update parameter ${paramId} for ${filterId}:`, error);
            }
        }
        
        async function toggleFilter(filterId) {
            try {
                const response = await fetch('/control/toggle_filter', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filter_id: filterId })
                });
                const data = await response.json();
                disabledFilters = new Set(data.disabled_filters);
                renderLists(); // Re-render to update UI state
            } catch (error) {
                console.error('Failed to toggle filter:', error);
            }
        }

        function renderLists() {
            availableContainer.innerHTML = '';
            activeList.innerHTML = '';

            const activeSet = new Set(activeEffects);

            // Render available filters
            for (const category in availableFiltersByCategory) {
                const categoryHeader = document.createElement('h3');
                categoryHeader.textContent = category;
                availableContainer.appendChild(categoryHeader);

                const categoryList = document.createElement('ul');
                categoryList.className = 'filter-list';
                categoryList.style.minHeight = 'auto';
                
                availableFiltersByCategory[category].forEach(filter => {
                    const li = createFilterItem(filter, activeSet.has(filter.identifier));
                    categoryList.appendChild(li);
                });
                availableContainer.appendChild(categoryList);
            }

            // Render active filters
            activeEffects.forEach(effectId => {
                const filter = allFiltersFlat.find(f => f.identifier === effectId);
                if (filter) {
                    const li = createFilterItem(filter, true);
                    activeList.appendChild(li);
                }
            });
        }

        function createFilterItem(filter, isActive) {
            const li = document.createElement('li');
            li.className = 'filter-item';
            li.dataset.identifier = filter.identifier;
            
            const header = document.createElement('div');
            header.className = 'filter-item-header';
            header.textContent = filter.name;

            const controls = document.createElement('div');
            controls.className = 'filter-item-controls';

            if (isActive) {
                li.draggable = true;
                li.classList.add('active-item');

                const isIndividuallyDisabled = disabledFilters.has(filter.identifier);
                if (isIndividuallyDisabled) {
                    li.classList.add('individually-disabled');
                }

                const disableBtn = document.createElement('button');
                disableBtn.className = 'small-btn';
                disableBtn.textContent = isIndividuallyDisabled ? 'Enable' : 'Disable';
                disableBtn.onclick = (e) => {
                    e.stopPropagation();
                    toggleFilter(filter.identifier);
                };
                controls.appendChild(disableBtn);

                const removeBtn = document.createElement('span');
                removeBtn.className = 'remove-btn';
                removeBtn.textContent = 'âœ•';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    activeEffects = activeEffects.filter(id => id !== filter.identifier);
                    renderLists();
                    sendStackUpdate();
                };
                controls.appendChild(removeBtn);

            } else { // Is in available list
                li.draggable = false;
                if (activeEffects.includes(filter.identifier)) {
                    li.classList.add('disabled');
                }
                
                const addBtn = document.createElement('button');
                addBtn.className = 'add-btn';
                addBtn.textContent = 'Add';
                if (activeEffects.includes(filter.identifier)) {
                    addBtn.disabled = true;
                }
                addBtn.onclick = async () => {
                    if (parameterValues[filter.identifier]) {
                        for (const paramId in parameterValues[filter.identifier]) {
                           await sendParameterUpdate(filter.identifier, paramId, parameterValues[filter.identifier][paramId]);
                        }
                    }
                    activeEffects.push(filter.identifier);
                    renderLists();
                    sendStackUpdate();
                };
                controls.appendChild(addBtn);
            }
            header.appendChild(controls);
            li.appendChild(header);

            // Add parameter controls
            if (filter.parameters && filter.parameters.length > 0) {
                const details = document.createElement('details');
                const summary = document.createElement('summary');
                summary.textContent = 'Settings';
                details.appendChild(summary);

                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'param-controls';
                filter.parameters.forEach(param => {
                    const currentVal = (parameterValues[filter.identifier] && parameterValues[filter.identifier][param.identifier] !== undefined)
                        ? parameterValues[filter.identifier][param.identifier]
                        : param.default;
                    
                    const label = document.createElement('label');
                    label.textContent = `${param.name}: `;
                    
                    if (param.type === 'slider') {
                        const valueSpan = document.createElement('span');
                        valueSpan.textContent = currentVal;
                        label.appendChild(valueSpan);

                        const slider = document.createElement('input');
                        slider.type = 'range';
                        slider.min = param.min;
                        slider.max = param.max;
                        slider.step = param.step;
                        slider.value = currentVal;
                        slider.oninput = (e) => {
                            valueSpan.textContent = e.target.value;
                            sendParameterUpdate(filter.identifier, param.identifier, e.target.value);
                        };
                        controlsDiv.appendChild(label);
                        controlsDiv.appendChild(slider);
                    } else if (param.type === 'select') {
                        const select = document.createElement('select');
                        param.options.forEach(option => {
                            const opt = document.createElement('option');
                            opt.value = option;
                            opt.textContent = option;
                            if (option === currentVal) {
                                opt.selected = true;
                            }
                            select.appendChild(opt);
                        });
                        select.onchange = (e) => {
                            sendParameterUpdate(filter.identifier, param.identifier, e.target.value);
                        };
                        controlsDiv.appendChild(label);
                        controlsDiv.appendChild(select);
                    }
                });
                details.appendChild(controlsDiv);
                li.appendChild(details);
            }
            return li;
        }

        async function pollStatus() {
            try {
                const response = await fetch('/control/status');
                const data = await response.json();
                
                const activeEffectsChanged = JSON.stringify(activeEffects) !== JSON.stringify(data.active_effects);
                const effectsEnabledChanged = effectsEnabled !== data.effects_enabled;
                const disabledFiltersChanged = JSON.stringify(Array.from(disabledFilters)) !== JSON.stringify(data.disabled_filters);

                if (activeEffectsChanged || effectsEnabledChanged || disabledFiltersChanged) {
                    activeEffects = data.active_effects;
                    effectsEnabled = data.effects_enabled;
                    disabledFilters = new Set(data.disabled_filters);
                    updateDisableUI();
                    renderLists();
                }
            } catch (error) {
                console.error('Polling failed:', error);
            }
        }

        async function initializeUI() {
            try {
                const response = await fetch('/control/status');
                const data = await response.json();
                availableFiltersByCategory = data.available_filters_by_category;
                allFiltersFlat = Object.values(availableFiltersByCategory).flat();
                activeEffects = data.active_effects;
                effectsEnabled = data.effects_enabled;
                parameterValues = data.parameter_values;
                disabledFilters = new Set(data.disabled_filters);
                
                updateDisableUI();
                renderLists();

                setInterval(pollStatus, 2000);
            } catch (error) {
                console.error('Failed to initialize UI:', error);
            }
        }

        function updateDisableUI() {
            if (effectsEnabled) {
                toggleAllBtn.textContent = 'Disable All';
                activeColumn.classList.remove('disabled');
            } else {
                toggleAllBtn.textContent = 'Enable All';
                activeColumn.classList.add('disabled');
            }
        }
        
        // Event Listeners
        clearStackBtn.addEventListener('click', () => {
            if (window.confirm('Are you sure you want to clear all active filters?')) {
                activeEffects = [];
                renderLists();
                sendStackUpdate();
            }
        });

        toggleAllBtn.addEventListener('click', async () => {
            const action = effectsEnabled ? 'disable' : 'enable';
            if (window.confirm(`Are you sure you want to ${action} all active filters?`)) {
                try {
                    const response = await fetch('/control/toggle_all', { method: 'POST' });
                    const data = await response.json();
                    effectsEnabled = data.effects_enabled;
                    updateDisableUI();
                } catch (error) {
                    console.error('Failed to toggle effects:', error);
                }
            }
        });

        // Drag and Drop Logic
        document.addEventListener('dragstart', (e) => {
            if (e.target.classList.contains('active-item')) {
                draggedItem = e.target;
                setTimeout(() => e.target.classList.add('dragging'), 0);
            }
        });

        document.addEventListener('dragend', (e) => {
            if (draggedItem) {
                draggedItem.classList.remove('dragging');
                draggedItem = null;
                sendStackUpdate();
            }
        });

        activeList.addEventListener('dragover', (e) => {
            e.preventDefault();
            const afterElement = getDragAfterElement(activeList, e.clientY);
            if (draggedItem) {
                if (afterElement == null) {
                    activeList.appendChild(draggedItem);
                } else {
                    activeList.insertBefore(draggedItem, afterElement);
                }
            }
        });

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.filter-item:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        document.addEventListener('DOMContentLoaded', initializeUI);
    </script>
</body>
</html>
