<!DOCTYPE html>
<html>
<head>
    <title>StreamFX Control</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 20px; background-color: #f0f2f5; color: #1c1e21; }
        .main-container { max-width: 800px; margin: 0 auto; }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;}
        .header h1 { margin: 0; color: #1877f2; }
        .header-controls button { margin-left: 10px; }
        .columns { display: flex; gap: 20px; }
        .column { flex: 1; background-color: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: opacity 0.3s; }
        .column.disabled { opacity: 0.5; pointer-events: none; background-color: #f0f2f5; }
        h2 { font-size: 1.2em; color: #606770; border-bottom: 1px solid #ddd; padding-bottom: 10px; margin-top: 0; }
        h3 { font-size: 1em; color: #606770; margin-top: 20px; margin-bottom: 10px; }
        .filter-list { min-height: 200px; list-style-type: none; padding: 0; }
        .filter-item { background-color: #e4e6eb; color: #050505; padding: 10px; margin-bottom: 8px; border-radius: 6px; cursor: grab; user-select: none; }
        .filter-item-header { display: flex; justify-content: space-between; align-items: center; }
        .filter-item:active { cursor: grabbing; }
        .remove-btn { cursor: pointer; color: #606770; font-weight: bold; padding: 0 5px; }
        .dragging { opacity: 0.5; }
        .small-btn { font-size: 0.8em; padding: 6px 10px; cursor: pointer; background-color: #ddd; border: none; border-radius: 4px; }
        .param-controls { margin-top: 10px; padding-top: 10px; border-top: 1px solid #ccc; font-size: 0.9em; }
        .param-controls label { display: block; margin-bottom: 5px; }
        .param-controls input[type="range"], .param-controls select { width: 100%; box-sizing: border-box; padding: 5px; }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="header">
            <h1>StreamFX Control</h1>
            <div class="header-controls">
                <button id="clear-stack-btn" class="small-btn">Clear All</button>
                <button id="toggle-all-btn" class="small-btn">Disable All</button>
            </div>
        </div>
        <div class="columns" id="columns-container">
            <div class="column" id="available-column">
                <h2>Available Filters</h2>
                <div id="available-filters-container"></div>
            </div>
            <div class="column" id="active-column">
                <h2>Active Filter Stack</h2>
                <ul id="active-filters" class="filter-list"></ul>
            </div>
        </div>
    </div>
    <script>
        const availableContainer = document.getElementById('available-filters-container');
        const activeList = document.getElementById('active-filters');
        const clearStackBtn = document.getElementById('clear-stack-btn');
        const toggleAllBtn = document.getElementById('toggle-all-btn');
        const activeColumn = document.getElementById('active-column');
        
        let availableFiltersByCategory = {};
        let allFiltersFlat = [];
        let activeEffects = [];
        let effectsEnabled = true;
        let parameterValues = {};
        let draggedItem = null;

        async function sendStackUpdate() {
            const newStack = Array.from(activeList.children).map(item => item.dataset.identifier);
            try {
                const response = await fetch('/control/set_stack', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ effects: newStack })
                });
                const data = await response.json();
                activeEffects = data.active_effects;
                renderLists();
            } catch (error) {
                console.error('Failed to update stack:', error);
            }
        }

        async function sendParameterUpdate(filterId, paramId, value) {
            try {
                await fetch('/control/update_parameter', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filter_id: filterId, params: { [paramId]: value } })
                });
            } catch (error) {
                console.error(`Failed to update parameter ${paramId} for ${filterId}:`, error);
            }
        }

        function renderLists() {
            availableContainer.innerHTML = '';
            activeList.innerHTML = '';

            const activeSet = new Set(activeEffects);

            // Render available filters
            for (const category in availableFiltersByCategory) {
                const categoryHeader = document.createElement('h3');
                categoryHeader.textContent = category;
                availableContainer.appendChild(categoryHeader);

                const categoryList = document.createElement('ul');
                categoryList.className = 'filter-list';
                categoryList.style.minHeight = 'auto';
                
                availableFiltersByCategory[category].forEach(filter => {
                    if (!activeSet.has(filter.identifier)) {
                        const li = createFilterItem(filter, false);
                        categoryList.appendChild(li);
                    }
                });
                availableContainer.appendChild(categoryList);
            }

            // Render active filters
            activeEffects.forEach(effectId => {
                const filter = allFiltersFlat.find(f => f.identifier === effectId);
                if (filter) {
                    const li = createFilterItem(filter, true);
                    activeList.appendChild(li);
                }
            });
        }

        function createFilterItem(filter, isActive) {
            const li = document.createElement('li');
            li.className = 'filter-item';
            li.dataset.identifier = filter.identifier;
            li.draggable = true;

            const header = document.createElement('div');
            header.className = 'filter-item-header';
            header.textContent = filter.name;
            
            if (isActive) {
                const removeBtn = document.createElement('span');
                removeBtn.className = 'remove-btn';
                removeBtn.textContent = 'âœ•';
                removeBtn.onclick = (e) => {
                    e.stopPropagation();
                    activeEffects = activeEffects.filter(id => id !== filter.identifier);
                    renderLists();
                    sendStackUpdate();
                };
                header.appendChild(removeBtn);
                li.appendChild(header);

                // Add parameter controls
                if (filter.parameters && filter.parameters.length > 0) {
                    const controlsDiv = document.createElement('div');
                    controlsDiv.className = 'param-controls';
                    filter.parameters.forEach(param => {
                        const currentVal = (parameterValues[filter.identifier] && parameterValues[filter.identifier][param.identifier] !== undefined)
                            ? parameterValues[filter.identifier][param.identifier]
                            : param.default;

                        const label = document.createElement('label');
                        label.textContent = `${param.name}: `;
                        
                        if (param.type === 'slider') {
                            const valueSpan = document.createElement('span');
                            valueSpan.textContent = currentVal;
                            label.appendChild(valueSpan);

                            const slider = document.createElement('input');
                            slider.type = 'range';
                            slider.min = param.min;
                            slider.max = param.max;
                            slider.step = param.step;
                            slider.value = currentVal;
                            slider.oninput = (e) => {
                                valueSpan.textContent = e.target.value;
                                sendParameterUpdate(filter.identifier, param.identifier, e.target.value);
                            };
                            controlsDiv.appendChild(label);
                            controlsDiv.appendChild(slider);
                        } else if (param.type === 'select') {
                            const select = document.createElement('select');
                            param.options.forEach(option => {
                                const opt = document.createElement('option');
                                opt.value = option;
                                opt.textContent = option;
                                if (option === currentVal) {
                                    opt.selected = true;
                                }
                                select.appendChild(opt);
                            });
                            select.onchange = (e) => {
                                sendParameterUpdate(filter.identifier, param.identifier, e.target.value);
                            };
                            controlsDiv.appendChild(label);
                            controlsDiv.appendChild(select);
                        }
                    });
                    li.appendChild(controlsDiv);
                }

            } else {
                li.appendChild(header);
                li.onclick = () => {
                    activeEffects.push(filter.identifier);
                    renderLists();
                    sendStackUpdate();
                };
            }
            return li;
        }

        async function pollStatus() {
            try {
                const response = await fetch('/control/status');
                const data = await response.json();
                
                if (JSON.stringify(activeEffects) !== JSON.stringify(data.active_effects) || effectsEnabled !== data.effects_enabled) {
                    activeEffects = data.active_effects;
                    effectsEnabled = data.effects_enabled;
                    updateDisableUI();
                    renderLists();
                }
            } catch (error) {
                console.error('Polling failed:', error);
            }
        }

        async function initializeUI() {
            try {
                const response = await fetch('/control/status');
                const data = await response.json();
                availableFiltersByCategory = data.available_filters_by_category;
                allFiltersFlat = Object.values(availableFiltersByCategory).flat();
                activeEffects = data.active_effects;
                effectsEnabled = data.effects_enabled;
                parameterValues = data.parameter_values;
                
                updateDisableUI();
                renderLists();

                setInterval(pollStatus, 2000);
            } catch (error) {
                console.error('Failed to initialize UI:', error);
            }
        }

        function updateDisableUI() {
            if (effectsEnabled) {
                toggleAllBtn.textContent = 'Disable All';
                activeColumn.classList.remove('disabled');
            } else {
                toggleAllBtn.textContent = 'Enable All';
                activeColumn.classList.add('disabled');
            }
        }
        
        // Event Listeners
        clearStackBtn.addEventListener('click', () => {
            if (window.confirm('Are you sure you want to clear all active filters?')) {
                activeEffects = [];
                renderLists();
                sendStackUpdate();
            }
        });

        toggleAllBtn.addEventListener('click', async () => {
            const action = effectsEnabled ? 'disable' : 'enable';
            if (window.confirm(`Are you sure you want to ${action} all active filters?`)) {
                try {
                    const response = await fetch('/control/toggle_all', { method: 'POST' });
                    const data = await response.json();
                    effectsEnabled = data.effects_enabled;
                    updateDisableUI();
                } catch (error) {
                    console.error('Failed to toggle effects:', error);
                }
            }
        });

        // Drag and Drop Logic
        document.addEventListener('dragstart', (e) => {
            if (e.target.classList.contains('filter-item') && e.target.parentElement.id === 'active-filters') {
                draggedItem = e.target;
                setTimeout(() => e.target.classList.add('dragging'), 0);
            }
        });

        document.addEventListener('dragend', (e) => {
            if (draggedItem) {
                draggedItem.classList.remove('dragging');
                draggedItem = null;
                sendStackUpdate();
            }
        });

        activeList.addEventListener('dragover', (e) => {
            e.preventDefault();
            const afterElement = getDragAfterElement(activeList, e.clientY);
            if (draggedItem) {
                if (afterElement == null) {
                    activeList.appendChild(draggedItem);
                } else {
                    activeList.insertBefore(draggedItem, afterElement);
                }
            }
        });

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.filter-item:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        document.addEventListener('DOMContentLoaded', initializeUI);
    </script>
</body>
</html>
